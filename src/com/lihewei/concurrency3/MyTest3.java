package com.lihewei.concurrency3;

/**
 * @author:lihewei
 * jvm中的同步基于进入与退出监视器（管程对象）（moniter）来实现的，每个对象实例都会有一个monitor对象，monitor对象
 * 会和java对象一同创建和销毁，moniter对象是由c++来实现的。
 * openJDK
 * 当多个线程同时访问同步代码块，这个线程会被放入到entryList集合中，处于阻塞状态的线程都会被放到该列表中，当线程
 * 获取到对象的monitor时，moniter是依赖于操作系统mutex lock来实现的互斥的，线程获取mutex时，则会持有该mutex，这时其他线程就无法
 * 再去获取到mutex。
 *
 * 如果线程调用了wait方法，那么该线程就会释放掉所有的mutex，并且该线程会进入到waitset集合（等待集合）时，等待下一次被其他线程调用
 * notiy/notifyAll 唤醒，如果当前线程顺利执行完毕，那么他会释放掉所有的wait
 * waitset 如果没有获取到锁，就会进入entrylist
 *
 * 总结一下，同步锁在这种方式，因为monitor是依赖与底层的操作系统实现的，这样就存在用户态与内核态之间的切换，所以会增加性能开销，通过
 * 对象互斥的概念来保证共享数据操作的完整性，每个对象都对应与=于一个可称为【互斥锁】的标记，这个标记用于保证在任何时刻，只能又一个线程
 * 对象。
 *
 * 那些处于entrylist 与 waitset 中的线程均处于阻塞状态，阻塞操作是操作系统来完成的，在liunx下是通过pthread_mutex_lock
 * 函数实现的，线程会被阻塞后进入到内核调度状态，这会导致系统在用户态与内核态来回切换，严重影响锁的性能。
 * 解决上述问题的办法就是自旋，其原理是：当发生Monitor 的争用时，若owner 能够子啊很短时间内释放掉锁，则那些正在争用的线程就可以稍微等待一下
 * （即所谓的自旋 spin），在owener线程释放锁之后，争用线程可能会立即获取到锁，从而避免了系统的阻塞，不过，当owner运行的时间超过了临界值后，
 * 争用线程自旋一段时间后依然无法获取到锁，这时争用线程就会停止自旋而进入阻塞状态，所以总体来说的思想是，不成功在进入阻塞，尽量
 * 降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升，显然，自旋在多处理器（多核心）才有意义。
 *
 *  互斥锁的属性：
 *  1。PTHREAD_MUTEX_TIMED_NP: 这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级
 *  获取到锁，这种策略可以确保资源分配的公平性
 *  2。PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许同一个线程对同一个锁成功获取多次，并通过unlock解锁，如果是不同线程的请求，则在
 *  加锁线程解锁时重新进行竞争。
 *  3.PTHREAD_MUTEX_ERRORCHECK_NP:检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同，这样
 *  就保证了当不允许多次加锁时不会出现最简单情况下的死锁。
 *  4.PTHREAD_MUTEX_ADAPTIVE_NP:适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争
 *
 *
 *  http://openjdk.java.net
 *
 *  ====================
 *  从jdk 1。5 开始，并发引入 lock锁，lock 同步锁是基于java 来实现的，因此锁的获取与释放都是通过java代码来实现与控制的，然后sysn
 *  是居于底层操作系统的mutex lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大增加系统的负担。
 *  当并发量较高时，也就是锁的竞争比较激烈的时候，synchornized 锁在性能上的表现就会非常差。
 *
 *  从 jdk1.6开始，synch锁的实现发生了很大的变化，jvm引入了相应的优化手段来提升syn锁的性能，这种提升涉及到偏向锁，轻量级锁，重量锁等，
 *  从而减少锁的竞争所带来的用户态和内核态的切换。这种锁的优化是通过Java对象头中的一些标志为来实现的。对于锁的访问与改变，实际上都与Java对象头
 *  息息相关
 *
 *  从jdk1。6开始，对象实例在堆当中被划分为三个部分： 对象头，实例数与对齐填充。
 *
 *  对象头主要由3块内容类构成。
 *  1。mark word
 *  2。 指向类的指针
 *  3。数组长度
 *
 *  其中mark word（他记录了对象，锁以及来及回收相关的信息，在64位的jvm中，其长度也是64bit的位信息包括了如下组成部分：
 *  1。无锁标记
 *  2。偏向锁标记
 *  3。轻量级锁标记
 *  4。重量级锁标记
 *  5。GC标记）
 *  对于syncharonized 锁来说，锁的升级主要都是通过mark word 中的锁标志位与是否偏向锁标志位来达成的，
 *  syn关键字对应的锁都是从偏向锁开始，随着锁竞争的不断升级，逐步演化轻量级锁，最后变成了重量级锁。
 *
 *  对于锁的演化，
 *  无锁--》偏向锁--》轻量级锁--》重量级锁
 *  jvm 启动参数，
 *  偏向锁：
 *  针对于一个线程来说，它的主要作用就是优化一个线程多次获取一个锁的情况；如果一个syn方法被一个线程访问，那么这个方法所在对象
 *  就会在其Mark word中的将偏向锁进行标记，同时还会有一个字段来存储该线程ID，当这个线程再次访问同一个syn方法时，它会检查这个对象
 *  的mark down 的偏向锁标记以及是否指向了其线程ID，
 *  如果是的话，那么该线程就无需再去进入管程（monitor），而是直接进入到该方法中。
 *  如果是另一个线程访问这个syn方法，那么实际情况就会如何？
 *  偏向锁就会被取消掉。
 *
 *  轻量级锁：
 *  若第一个线程已经获取到了当前对象的锁，这时第二个线程又开始尝试争抢对象的锁，由于该对象的锁已经被第一个线程获取到，因此他是偏向锁，
 *  而第二个线程在争抢时，会发现该对象头mark word 已经是偏向锁，但里面存储的线程ID并不是自己（是第一个线程），那么他会进行cas（compare and swap），
 *  从而获取到锁，这里面存在两种情况
 *  1。获取锁成功：那么它会直接mark word 中的线程ID由第一个线程变成自己（偏向锁标记位保持不变），这样该对象依然会保持偏向锁的状态
 *  2。获取锁失败，则表示这时可能会有多个线程同时在尝试该对象的锁，那么这时偏向锁就会进行升级，升级位轻量级锁。
 *
 *  自旋锁：
 *  若自旋锁（依然无法获取到锁),那么锁就会转化为重量级锁，在这种情况下，无法获取锁的线程都会进入到Monitor（即内核态）
 *  自旋最大的一个特点就是避免从用户态进入到内核态。
 *
 *  重量级锁：
 *  线程最终从用户态进入到了内核态
 *
 *
 *
 *
 */
public class MyTest3 {
    public  static  synchronized  void method(){
        System.out.println("hello world");
    }
}
/**
 * public static synchronized void method();
 *     descriptor: ()V
 *     flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
 *     Code:
 *       stack=2, locals=0, args_size=0
 *          0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
 *          3: ldc           #3                  // String hello wrold
 *          5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
 *          8: return
 *       LineNumberTable:
 *         line 8: 0
 *         line 9: 8
 * }
 */
